(:title Обзор новых возможностей в Python 2.6 и 3.0:)
(:keywords скрипты, python, исходники, программирование, Python 2.6, Python 3.0, Python 3000, новые возможности Python:)

(:description Обзор новых возможностей языка Python версий 2.6 и 3.0:)

%center%(:Googlebigarticle:)

!! Оглавление

[[#intro | 1. Введение]]\\
[[#string | 2. Строки и Unicode]]\\
[[#print | 3. Функция print()]]\\
[[#format | 4. Форматирование строк]]\\
[[#property | 5. Свойства]]\\
[[#abstract | 6. Абстрактные базовые классы]]\\
[[#exceptions | 7. Обработка исключений]]\\
[[#with | 8. Оператор with]]\\
[[#math | 9. Математика]]\\
[[#other | 10. Разное]]\\
[[#finally | 11. Заключение]]\\
[[#links | 12. Ссылки]]\\
[[#comments | Комментарии]]\\

[[#intro]]
!! 1. Введение
В сентябре 2008 года должны выйти сразу две версии языка Python - 2.6 и 3.0. Версия 3.0 потеряет обратную совместимость с линейкой 2.x, но облегчить переход на новую ветку должна версия 2.6, в которой будут реализованы основные возможности из Python 3.0, но в которой еще сохранится обратная совместимость с предыдущими версиями. Таким образом, в версии 2.6 уже можно будет пользоваться многими возможностями Python 3.0, но в то же время старый код будет продолжать работать, и будет время для перехода на Python 3.0.

В этой статье мы с вами рассмотрим основные изменения, которые произошли в Python 2.6 и 3.0 по сравнению с Python 2.5. Для запуска примеров использовались первые бета-версии Python 2.6 и 3.0, поэтому к выходу финальной версии еще может что-то измениться.

[[#string]]
!! 2. Строки и Unicode

В Python 3.0 все строки стали юникодными. С формальной точки зрения строки остались экземплярами класса ''str'', а ''unicode'' исчез как класс. :) Не стало даже спецификатора ''u'' перед кавычками. В Python 2.6 по-прежнему остались два типа строк - ''str'' и ''unicode''.

Кроме того, в Python 3.0 изменилась встроенная функция ''str()'', теперь она, по сути, заменяет старую функцию ''unicode()'' и принимает те же три параметра - объект для преобразования в строку, строку, определяющую кодировку, и строку, определяющую поведение функции на случай, если ''str()'' не сможет преобразовать какие-то символы.

[[#print]]
!! 3. Функция print()
В Python 3.0 не стало ключевого слова ''print'', зато появилась встроенная функция ''print()''. В Python 2.6 ключевое слово ''print'' осталось, но добавилась возможность использовать одноименную функцию, для чего надо импортировать ''print_function'' из модуля '' __future__ '':

(:source lang=python tabwidth=4:)
from __future__ import print_function
(:sourcend:)

Напомню, что это импорт из модуля '' __future__ '' должен стоять в самом начале исходника, даже до импорта других модулей, иначе Python напишет такую ошибку:

(:source:)
  File "H:\Черновики\Python 2.6 & 3.0\print_2.py", line 3
    from __future__ import print_function
SyntaxError: from __future__ imports must occur at the beginning of the file
(:sourcend:)

Функция ''print()'' определена следующим образом:

(:source:)
print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout]) 
(:sourcend:)

Сначала идут объекты, которые надо вывести.\\
'''sep''' - разделитель между объектами, по умолчанию - пробел\\
'''end''' - строка, выводимая в конце, по умолчанию - символ перевода строки ''\n''.\\
'''file''' определяет то, куда будет выводиться строка. По умолчанию вывод направлен в консоль.

Давайте сравним результаты работы двух исходников (оба запускались в Python 2.6). В первом случае ''print'' - ключевое слово.

(:source lang=python tabwidth=4:)
print ("test")
print ()
print "test1", "test2"
print ("test1", "test2")
(:sourcend:)

В результате получим:

(:source:)
test
()
test1 test2
('test1', 'test2')
(:sourcend:)

И то же самое, но если используется функция ''print()'':

(:source lang=python tabwidth=4:)
from __future__ import print_function

print ("test")
print ()
print ("test1", "test2")
(:sourcend:)

Результатом работы этого кода будет:

(:source:)
test

test1 test2
(:sourcend:)

Как видите, при переходе от ключевого слова к функции надо быть особенно аккуратным при использовании кортежей.

В заключении этого раздела проиллюстрируем использование дополнительных параметров функции ''print()'':

(:source lang=python tabwidth=4:)
from __future__ import print_function

print ("test1", "test2", "test3")
print ("test4", "test5", "test6", sep = " # ")
print ("test7", "test8", "test9", end = "###")
print ("test10", "test11", "test12")

fp = file ("print_test.txt", "w")
print ("Тест1", "Тест2", "Тест3", file = fp)
fp.close()
(:sourcend:)

Если запустить этот скрипт из-под Python 2.6, то в результате в консоли будет выведено:

(:source:)
test1 test2 test3
test4 # test5 # test6
test7 test8 test9###test10 test11 test12
(:sourcend:)

Кроме того, будет создан файл с именем print_test.txt, который будет содержать строку "Тест1 Тест2 Тест3". 


[[#format]]
!! 4. Форматирование строк
В Python 2.6 и 3.0 появился новый способ форматирования строк, причем способ с помощью оператора ''%'' тоже работает. Новый способ форматирования напоминает функцию [[Programming.Netstring | String.Format() из .NET Framework]]. 

Теперь у класса ''str'' есть новый метод - ''format()'', работу которого мы сейчас и рассмотрим. Думаю, что не стоит приводить полный синтаксис форматирования (его вы можете найти в [[http://docs.python.org/dev/library/string.html#formatstrings | документации]]), а лучше рассмотрим достаточно большое количество примеров.

Начнем с простого:

(:source lang=python tabwidth=4:)
listval = [1.1, 2.2, 3.3]
print ("{0} | {1} | {2} | {3}".format (45, 123.4, "abyrvalg", listval) )
(:sourcend:)

В результате выполнения этого кода на экран будет выведен следующий текст:

(:source:)
45 | 123.4 | abyrvalg | [1.1000000000000001, 2.2000000000000002, 3.2999999999999998]
(:sourcend:)

Таким образом метод ''format()'' подставил вместо выражений ''{0}'', ''{1}'', ..., ''{3}'' значения параметров, которые были ему переданы. Заметьте, что в строке форматирования параметры в фигурных скобках не обязательно должны идти в той последовательности, в которой они передаются в метод ''format()''. Например, вполне нормально будет работать следующий код:

(:source lang=python tabwidth=4:)
print ("{1} | {0} | {3} | {2}".format (45, 123.4, "abyrvalg", listval) )
(:sourcend:)

В результате на экран будет выведена строка

(:source:)
123.4 | 45 | [1.1000000000000001, 2.2000000000000002, 3.2999999999999998] | abyrvalg
(:sourcend:)

Для каждого из параметров внутри фигурных скобок после двоеточия можно задать способ форматирования. В том числе, можно задать формат и систему счисления, в которой будут выводиться числа. Например:

(:source lang=python tabwidth=4:)
>>> # Обычный десятичный формат
>>> print ("Decimal: {0:d}".format (45) )
Decimal: 45

>>> # Двоичный формат
>>> print ("Binary: {0:b}".format (45) )
Binary: 101101

>>> # Восьмиричный формат
>>> print ("Octal: {0:o}".format (45) )
Octal: 55

>>> # Шестнадцатиричный формат
>>> print ("Hex: {0:x}".format (45) )
Hex: 2d

>>> print ("Hex: {0:X}".format (45) )
Hex: 2D


>>> # Основной формат, используемый по умолчанию
>>> print ("General: {0:g}".format (123.4) )
General: 123.4

>>> # Экспоненциальный формат
>>> print ("Exponent: {0:e}".format (45) )
Exponent: 4.500000e+01

>>> print ("Exponent: {0:E}".format (45) )
Exponent: 4.500000E+01

>>> # Вывод процентов. Число будет умножено на 100
>>> print ("Percent: {0:%}".format (0.25) )
Percent: 25.000000%
(:sourcend:)

Можно также задать размер (ширину) "ячейки", отводимой для числа. Если для вывода числа требуется меньше символов, чем ему отведено, то оставшиеся символы заполняются пробелами. В этом случае можно использовать дополнительный параметр, определяющий выравнивание числа внутри "ячейки". Если число не влезает в выделенную ячейку, то параметр, задающий ширину игнорируется.

В следующей группе примеров для числа отводится 15 символов.

(:source lang=python tabwidth=4:)
>>> # Используется выравнивание по умолчанию (по правому краю)
>>> print ("|{0:15}|".format (-19) )
|            -19|

>>> # То же выравнивание можно задать явно с помощью символа '>'
>>> print ("|{0:>15}|".format (-19) )
|            -19|

>>> # Выравнивание по левому краю задается с помощью символа '<'
>>> print ("|{0:<15}|".format (-19) )
|-19            |

>>> # Выравнивание по центру задается с помощью символа '^'
>>> print ("|{0:^15}|".format (-19) )
|      -19      |

>>> # Знак числа будет выровнен по левому краю, а само число по правому. Для этого используется символ '='
>>> print ("|{0:=15}|".format (-19) )
|-            19|
(:sourcend:)

Кроме того, можно задать точность вывода дробных чисел, а точнее, задать количество выводимых цифр. Этот параметр записывается после точки в строке форматирования. В следующей группе примеров задание точности объединено с заданием ширины "ячейки".

(:source lang=python tabwidth=4:)
>>> print ("|{0:15.4g}|".format (-22.56789) )
|         -22.57|

>>> print ("|{0:15.5g}|".format (-22.56789) )
|        -22.568|

>>> print ("|{0:15.15g}|".format (-22.56789) )
|      -22.56789|

>>> print ("|{0:15.1g}|".format (-22.56789) )
|         -2e+01|
(:sourcend:)

Порядок следования подстановочных параметров в строке форматирования можно задавать не только с помощью порядкового номера параметра метода format(), но и давая им имена, например:

(:source lang=python tabwidth=4:)
>>> print ("x = {x}; y = {y}".format (x = 124.2, y = 56.8) )
x = 124.2; y = 56.8
(:sourcend:)

Здесь параметрам мы дали имена ''x'' и ''y'', которые также используются в фигурных скобках.

Можно также комбинировать эти два способа. Хотя мне кажется, что это будет только запутывать код, однако возможность такая есть:

(:source lang=python tabwidth=4:)
>>> print ("x = {0}; y = {y}".format (124.2, y = 56.8) )
x = 124.2; y = 56.8
(:sourcend:)

Кроме перечисленных у метода ''format()'' есть еще несколько настроек форматирования, который мы рассматривать не будем.

[[#property]]
!! 5. Свойства

В новых версиях Python появился новый, более удобный способ задания свойств. До Python 2.6 и 3.0 класс со свойствами мог выглядеть примерно так:

(:source lang=python tabwidth=4:)
class Foo(object):
	def __init__(self, xval): 
		print ("*** Foo.__init__()")
		self._x = xval

	def getx(self):
		print ("*** X.Getter(): x = %d" % self._x )
		return self._x

	def setx(self, value):
		self._x = value
		print ("*** X.Setter(): new x value = %d" % self._x )

	x = property (getx, setx)

f = Foo(123)
print (f.x)

f.x = 345
print (f.x)
(:sourcend:)

Теперь тот же код можно переписать следующим образом:

(:source lang=python tabwidth=4:)
class Foo(object):
	def __init__(self, xval): 
		print ("*** Foo.__init__()")
		self._x = xval

	@property
	def x(self):
		print ("*** X.Getter(): x = %d" % self._x )
		return self._x

	@x.setter
	def x(self, value):
		self._x = value
		print ("*** X.Setter(): new x value = %d" % self._x )

f = Foo(123)
print (f.x)

f.x = 345
print (f.x)
(:sourcend:)

Внутри класса метод для получения значения свойства (getter) можно пометить декоратором ''@property'', а метод для установки значения свойства (setter) - декоратором, имя которого представляет собой имя_свойства.setter.

Кроме того, по аналогии с setter так же можно объявлять deleter, который вызывается, если к свойству применить функцию ''del()''. Вот пример использования такого свойства:

(:source lang=python tabwidth=4:)
class Foo(object):
	def __init__(self, xval): 
		print ("*** Foo.__init__()")
		self._x = xval

	@property
	def x(self):
		print ("*** X.Getter(): x = %d" % self._x )
		return self._x

	@x.setter
	def x(self, value):
		self._x = value
		print ("*** X.Setter(): new x value = %d" % self._x )

	@x.deleter
	def x(self):
		print ("*** X.Deleter()")
		del self._x

f = Foo(123)
print (f.x)

f.x = 345
print (f.x)

del f.x
(:sourcend:)

В результате выполнения этого кода в консоль будут выведены следующие строки:

(:source:)
*** Foo.__init__()
*** X.Getter(): x = 123
123
*** X.Setter(): new x value = 345
*** X.Getter(): x = 345
345
*** X.Deleter()
(:sourcend:)

[[#abstract]]
!! 6. Абстрактные базовые классы

Теперь, как и в других объектно-ориентированных языках программирования, в Python появилась возможность делать так называемые абстрактные базовые классы. Так называются классы, по которым нельзя сделать объекты, потому что в них не реализованы некоторые методы или свойства (абстрактные методы и свойства). Для создания объекта необходимо сначала создать класс, производный от абстрактного класса, внутри которого (пере)определить абстрактные методы и свойства. 

Для работы с абстрактными классами появился новый модуль - ''abc'' (сокращение от слов Abstract Base Classes).

Чтобы объявить класс абстрактным в Python 2.6, необходимо переменной '' __metaclass__ ''  в его определении присвоить значение ''abc.ABCMeta''.

(:source lang=python tabwidth=4:)
from abc import ABCMeta

class Foo (object):
	__metaclass__ = ABCMeta
(:sourcend:)

В Python 3.0 абстрактный класс должен быть объявлен следующим образом:

(:source lang=python tabwidth=4:)
class Foo (metaclass=ABCMeta):
(:sourcend:)

Не понятно почему разработчики сделали разные способы объявления классов абстрактными в версиях 2.6 и 3.0, причем способы способ с '' __metaclass__ = ABCMeta '' не работает в Python 3.0, а способ с ''class Foo (metaclass=ABCMeta)'' не работает в Python 2.6. 

Чтобы сделать абстрактный метод внутри класса, его надо пометить декоратором ''@abs.abstractmethod''.

Рассмотрим примеры использования абстрактных классов и методов. 

Python 2.6:

(:source lang=python tabwidth=4:)
from abc import ABCMeta
from abc import abstractmethod

class Foo (object):
	__metaclass__ = ABCMeta

	def __init__(self):
		print ("*** Foo.__init__()")
	
	@abstractmethod
	def run (self):
		print ("*** Foo.run()")
	
class Bar (Foo):
	def __init__ (self):
		print ("*** Bar.__init__()")
		Foo.__init__ (self)
	
	def run (self):
		print ("*** Bar.run()")
		
if __name__ == "__main__":
	bar_obj = Bar()
	bar_obj.run()
(:sourcend:)

Python 3.0:

(:source lang=python tabwidth=4:)
#-*- coding: utf-8 -*-

from abc import ABCMeta
from abc import abstractmethod

class Foo (metaclass = ABCMeta):
	def __init__(self):
		print ("*** Foo.__init__()")
	
	@abstractmethod
	def run (self):
		print ("*** Foo.run()")
	
class Bar (Foo):
	def __init__ (self):
		print ("*** Bar.__init__()")
		Foo.__init__ (self)
	
	def run (self):
		print ("*** Bar.run()")

class Bar2 (Foo):
	def __init__ (self):
		print ("*** Bar2.__init__()")
		Foo.__init__ (self)
		
if __name__ == "__main__":
	bar_obj = Bar()
	bar_obj.run()
(:sourcend:)

В результате выполнения этого скрипта мы получим следующий результат:

(:source:)
*** Bar.__init__()
*** Foo.__init__()
*** Bar.run()
(:sourcend:)

А теперь, мы попытаемся создать экземпляр класса Foo:

(:source lang=python tabwidth=4:)
foo_obj = Foo()
(:sourcend:)

В результате выполнения этой строки будет вызвано исключение:

(:source:)
Traceback (most recent call last):
  File "H:\Черновики\Python 2.6 & 3.0\abstract_1.py", line 33, in <module>
foo_obj = Foo()
	TypeError: Can't instantiate abstract class Foo with abstract methods run
(:sourcend:)

Теперь создадим другой производный от ''Foo'' класс - ''Bar2'', но "забудем" переопеределить абстрактный метод ''run()'':

(:source lang=python tabwidth=4:)
class Bar2 (Foo):
	def __init__ (self):
		print ("*** Bar2.__init__()")
		Foo.__init__ (self)
(:sourcend:)

Если попытаться создать экземпляр класса Bar2:

(:source lang=python tabwidth=4:)
bar2_obj = Bar2()
(:sourcend:)

то будет вызвано то же исключение:

(:source:)
Traceback (most recent call last):
  File "H:\Черновики\Python 2.6 & 3.0\abstract_1.py", line 35, in <module>
bar2_obj = Bar2()
TypeError: Can't instantiate abstract class Bar2 with abstract methods run
(:sourcend:)

Теперь попробуем объявим класс абстрактным, но без абстрактных методов, и попытаемся создать экземпляр такого класса в стиле Python 2.6 (дальше во всех примерах этого раздела будем использовать именно Python 2.6):

(:source lang=python tabwidth=4:)
from abc import ABCMeta
from abc import abstractmethod

class Foo (object):
	__metaclass__ = ABCMeta

	def __init__(self):
		print ("*** Foo.__init__()")
		
if __name__ == "__main__":
	foo_obj = Foo()
(:sourcend:)

Как ни странно, объект будет успешно создан и мы увидим строку

(:source:)
*** Foo.__init__()
 (:sourcend:)

Аналогично ведет себя и Python 3.0. Не знаю ошибка ли это в первых бетах или так и было задумано, но, ИМХО, такое поведение нелогично. Если уж объявлять класс абстрактным, то надо всегда запрещать создавать экземпляры этого класса независимо от того есть ли у него абстрактные методы (или свойства) или нет. 

Кроме методов абстрактными могут быть также и свойства. Чтобы пометить свойство как абстрактное, его getter надо пометить декоратором ''@abc.abstractproperty''. Например:

(:source lang=python tabwidth=4:)
from abc import ABCMeta, abstractproperty

class Foo (object):
	__metaclass__ = ABCMeta

	def __init__ (self):
		print ("*** Foo.__init__()")
		self._x = 0
	
	@abstractproperty
	def x (self):
		pass
 (:sourcend:)

В данном случае свойство ''x'' будет абстрактным и его необходимо переопределить в производном классе, например так:

(:source lang=python tabwidth=4:)
class Bar (Foo):
	def __init__ (self):
		print ("*** Bar.__init__()")
		Foo.__init__ (self)
	
	@property
	def x (self):
		return self._x
(:sourcend:)

Если теперь попытаемся создать объект класса ''Foo'', то снова получим исключение:

(:source:)
Traceback (most recent call last):
  File "H:\Черновики\Python 2.6 & 3.0\abstract_4.py", line 21, in <module>
foo_obj = Foo()
TypeError: Can't instantiate abstract class Foo with abstract methods x
(:sourcend:)

То же самое произойдет, если попытаться создать экземпляр производного от ''Foo'' класса, но без переопределения свойства ''x''.

Если мы хотим сделать абстрактным также и setter свойства, то придется воспользоваться старым стилем определения свойств:

(:source lang=python tabwidth=4:)
from abc import ABCMeta, abstractproperty

class Foo (object):
	__metaclass__ = ABCMeta

	def __init__ (self):
		print ("*** Foo.__init__()")
		self._x = 0
	
	def getx (self):
		pass

	def setx (self, value):
		pass

	x = abstractproperty(getx, setx)
(:sourcend:)

Использование этого класса может выглядеть примерно так (здесь мы уже можем воспользоваться новым способом создания свойств):

(:source lang=python tabwidth=4:)
class Bar (Foo):
	def __init__ (self):
		print ("*** Bar.__init__()")
		Foo.__init__ (self)
	
	@property
	def x (self):
		return self._x
	
	@x.setter
	def x (self, value):
		self._x = value

		
bar_obj = Bar()
bar_obj.x = 3
print (bar_obj.x)
(:sourcend:)

В результате работы этого скрипта получим:

(:source:)
*** Bar.__init__()
*** Foo.__init__()
3
(:sourcend:)

[[#exceptions]]
!! 7. Обработка исключений

Во-первых, небольшие изменения произошли и в синтаксисе при обработке исключений. Вот как раньше выглядел код при ожидании одного исключения (в нашем случае TypeError):

(:source lang=python tabwidth=4:)
try:
	raise TypeError("111")
except TypeError, exc:
	print (exc)
(:sourcend:)

В Python 2.6 этот метод будет работать, а вот в Python 3.0 будет ругаться на неверный синтаксис. Чтобы этот код работал и в Python 2.6, и в Python 3.0 (но не в Python 2.5 и ниже), в строке с ключевым словом ''except'' запятую необходимо заменить на ключевое слово ''as'':

(:source lang=python tabwidth=4:)
try:
	raise TypeError("111")
except TypeError as exc:
	print (exc)
(:sourcend:)

В случе, если надо отлавливать несколько исключений, данный пример будет выглядеть следующим образом:

(:source lang=python tabwidth=4:)
try:
	#raise TypeError("111")
	raise ValueError("222")
except (TypeError, ValueError) as exc:
	print (exc)
(:sourcend:)

Если верить документации, то такое изменение синтаксиса было сделано, чтобы лучше визуально отделить переменную типа исключения от списка ожидаемых исключений.

Кроме того, теперь в Python 3.0 классы всех вызываемых исключений обязаны быть производными от одного базового класса - ''BaseException'', в противном случае оператор ''raise'' вместо ожидаемого исключения вызовет исключение типа ''TypeError''. Однако в документации для пользовательских исключений в качестве базового класса рекомендуют использовать класс ''Exception'', а класс ''BaseException'' оставить для встроенных исключений.

Таким образом, теперь использование пользовательских исключений должно выглядеть примерно так:

(:source lang=python tabwidth=4:)
class FooException (Exception):
	def __init__ (self, val):
		Exception.__init__ (self, val)

try:
	raise FooException ("My Exception")
except FooException as exc:
	print (exc)
(:sourcend:)

А теперь рассмотрим ошибочный пример, если класс ''FooException'' не унаследован от ''BaseException'' или его потомков:

(:source lang=python tabwidth=4:)
class FooException ():
	def __init__ (self, val):
		pass

try:
	raise FooException ("My Exception")
except FooException as exc:
	print (exc)
(:sourcend:)

В Python 3.0 выражение ''raise FooException ("My Exception")'' вызовет исключение:

(:source:)
TypeError: catching classes that do not inherit from BaseException is not allowed
(:sourcend:)

В Python 2.6 без использования параметра командной строки ''-3'' (о нем более подробно мы поговорим ниже) этот пример будет работать без проблем, а при включении параметра ''-3'' выдаст сразу два предупреждения:

(:source:)
H:\Черновики\Python 2.6 & 3.0\exception_6.py:8: DeprecationWarning: exceptions must derive from BaseException in 3.x
  raise FooException ("My Exception")
H:\Черновики\Python 2.6 & 3.0\exception_6.py:9: DeprecationWarning: catching classes that don't inherit from BaseException is not allowed in 3.x
  except FooException as exc:
(:sourcend:)

[[#with]]
!! 8. Оператор with

Оператор ''with'' представляет собой некоторый аналог обертывания объекта в ''try'' / ''finally''. Он был введен еще в Python 2.5, но для его использования необходимо было импортировать ''with_statement'' из модуля '' __future__ '':

(:source lang=python tabwidth=4:)
from __future__ import with_statement
(:sourcend:)

Начиная, с Python 2.6 этого не требуется, и ''with'' стал обычным ключевым словом. 

Суть его состоит в том, что для объекта, подаваемого на вход оператора ''with'', сначала вызывается специальный метод - '' __enter__()'', а перед выходом из оператора  вызывается метод '' __exit__()'', причем метод '' __exit__()'' вызывается независимо от того был ли блок внутри оператора ''with'' выполнен до конца или он был прерван исключением.

Давайте рассмотрим пример и на нем разберемся с синтаксисом оператора ''with''. Поддержку оператора ''with'' имеет, например, класс ''File'', поэтому, чтобы быть уверенными, что файл в любом случае будет закрыт после записи, мы можем написать такой код:

(:source lang=python tabwidth=4:)
fname = "test.txt"

with file (fname, "w") as fp:
	fp.write ("Hello, with")

with file (fname, "w") as fp:
	fp.write ("Hello, with — 2")
(:sourcend:)

На входе оператора ''with'' мы создаем объект ''File'' с помощью выражения ''file (fname, "w")'' и присваиваем его переменной ''fp'' с помощью выражения ''as fp'', которое, строго говоря, является необязательным, если мы не хотим использовать созданный объект внутри блока оператора.

В этом примере блок ''with'' специально был использован дважды, чтобы показать, что файл test.txt после блока ''with'' закрыт, иначе при повторном открытии файла на запись произошло бы исключение. Как мы можем убедиться, файл test.txt будет создан и в нем будет записана строка «Hello, with — 2», т.е. вторая запись в файл будет успешно выполнена.

Давайте теперь создадим свой класс объектов, которые смогут использовать оператор ''with''. Рассмотрим следующий код:

(:source lang=python tabwidth=4:)
class Foo (object):
	def __init__ (self):
		print ("*** Foo.__init__()")
	
	def __enter__ (self):
		print ("*** Foo.__enter__()")
		return self
	
	def __exit__ (self, exc_type, exc_value, traceback):
		print ("*** Foo.__exit__()")
		print ("*** exc_type: {0}\n*** exc_value: {1}\n*** traceback: {2}".format (exc_type, exc_value, traceback) )
	
	def Run (self):
		print ("*** Foo.Run()")

if __name__ == "__main__":
	with Foo() as foo_obj:
		print ("With begin")
		foo_obj.Run()
		print ("With end")
	
	print ("After With")
(:sourcend:)

Здесь мы создали класс ''Foo'' и объявили в нем методы '' __enter__() '' и '' __exit__() ''. Начнем с первого.

У метода '' __enter__() '' нет никаких параметров кроме ''self''. При этом метод '' __enter__() '' должен возвращать значение, которое будет присвоено переменной, стоящей после ключевого слова ''as'' оператора ''with'', т.е. в нашем случае ''foo_obj''. Как видите, оператор ''as'' не просто присваивает переменной значение выражения внутри with. Мы могли бы вернуть из '' __enter__() '' объект другого класса.

У метода '' __exit__() '' кроме ''self'' есть еще три параметра, которые описывают возникшее внутри блока ''with'' исключение. 

'''exc_type''' - Тип исключения\\
'''exc_value''' - Значение исключения\\
'''traceback''' - трассировка вызовов

Если блок внутри ''with'' завершился без исключений, то все эти параметры равны ''None''. 

Теперь посмотрим результат работы последнего примера:

(:source:)
*** Foo.__init__()
*** Foo.__enter__()
With begin
*** Foo.Run()
With end
*** Foo.__exit__()
*** exc_type: None
*** exc_value: None
*** traceback: None
After With
(:sourcend:)

Итак, первое, что делает оператор ''with'', создает объект класса ''Foo'' и вызывает его метод '' __enter__() ''. Затем полностью выполняется блок внутри ''with'' и вызывается метод '' __exit__() '', значениями аргументов которого являются три ''None''.

Изменим пример так, чтобы метод ''Run()'' вызывал исключение:

(:source lang=python tabwidth=4:)
class Foo (object):
	def __init__ (self):
		print ("*** Foo.__init__()")
	
	def __enter__ (self):
		print ("*** Foo.__enter__()")
		return self
	
	def __exit__ (self, exc_type, exc_value, traceback):
		print ("*** Foo.__exit__()")
		print ("*** exc_type: {0}\n*** exc_value: {1}\n*** traceback: {2}".format (exc_type, exc_value, traceback) )
	
	def Run (self):
		raise AssertionError ("Run error")
		

if __name__ == "__main__":
	with Foo() as foo_obj:
		print ("With begin")
		foo_obj.Run()
		print ("With end")
	
	print ("After With")
(:sourcend:)

И его результат работы:

(:source:)
*** Foo.__init__()
*** Foo.__enter__()
With begin
*** Foo.__exit__()
*** exc_type: <type 'exceptions.AssertionError'>
*** exc_value: Run error
*** traceback: <traceback object at 0x00C3D620>
Traceback (most recent call last):
  File "H:\Черновики\py_26_with_3.py", line 22, in <module>
foo_obj.Run()
  File "H:\Черновики\py_26_with_3.py", line 16, in Run
raise AssertionError ("Run error")
AssertionError: Run error
(:sourcend:)

Таким образом с помощью оператора ''with'' мы действительно гарантируем, что метод '' __exit__() '' будет вызван. Думаю, дополнительных комментариев здесь не требуется. 

[[#math]]
!! 9. Математика

Еще одно заметное нововведение в Python 3.0 (в 2.6 этого нет) - это то, что для целочисленного деления теперь нужно будет использовать оператор '' // ''. Оператор '' / '' теперь используется для дробного деления.

Если раньше в результате выполнения строк

(:source lang=python tabwidth=4:)
print (3/2)
print (4/2)
(:sourcend:)

мы бы получили в качестве результата

(:source:)
1
2
(:sourcend:)

то в Python 3.0 оператор '' / '' предназначен для дробного деления, результатом которого является объект типа ''float'', и в результате выполнения этого же кода, мы получим:

(:source:)
1.5
2.0
(:sourcend:)

Для того, чтобы выполнить целочисленное деление, этот пример надо переписать в следующем виде:

(:source lang=python tabwidth=4:)
print (3//2)
print (4//2)
(:sourcend:)

В результате выполнения этих строк получим опять

(:source:)
1
2
(:sourcend:)

Гиперболические функции ''acosh()'', ''asinh()'' и ''atanh()'' теперь есть не только в модуле ''cmath'', но и в модуле ''math'' (это уже относится и к Python 3.0, и к Python 2.6).

Были введены особые числа с плавающей точкой - ''nan'' (not a number), ''+inf'' и ''-inf'' (соответственно, + и - бесконечности). Создавать их можно с помощью встроенной функции ''float()'':

(:source lang=python tabwidth=4:)
>>> float ('nan')
nan

>>> float ('-inf')
-inf

>>> float ('inf')
inf
(:sourcend:)

Рассмотрим несколько простых примеров с использованием этих чисел:

(:source lang=python tabwidth=4:)
>>> a = float ('inf')
>>> a
inf

>>> # Бесконечность, умноженная на 0
>>> a * 0
nan

>>> # Бесконечность, деленная на бесконечность
>>> a / a
nan

>>> # Очень большое число
>>> a=1.0e999
>>> a
inf

>>> # Бесконечность, умноженная на -1
>>> b = -a
>>> b
-inf

>>> # Деление бесконечностей разных знаков
>>> a/b
nan

>>> # Сумма бесконечностей разных знаков
>>> a + b
nan
(:sourcend:)

Для того, чтобы определить является ли число бесконечностью или ''NaN'', в модулях ''math'' и ''cmath'' созданы специальные функции - ''isnan()'' и ''isinf()'', которые возвращают ''True'', если число является ''NaN'' или бесконечностью соответственно, и ''False'' в противном случае.

В модуле ''math'' появилась новая функция - ''log1p(x)'', которая вычисляет натуральный логарифм от 1 + x.

(:source lang=python tabwidth=4:)
>>> math.log1p (0)
0.0

>>> math.log1p (1)
0.69314718055994529

>>> math.log (2)
0.69314718055994529
(:sourcend:)

В модуле ''cmath'' появились новые функции для работы с комплексными числами.

Функция ''polar()'' возвращает значение амплитуды и фазы комплексного числа в полярной системе координат:

(:source lang=python tabwidth=4:)
>>> r, phi = cmath.polar ( complex ('1+1j') )
>>> r
1.4142135623730951

>>> phi * 180.0 / math.pi
45.0
(:sourcend:)

Функция ''rect()'' модуля ''cmath'' делает обратную операцию - она создает комплексное число по значению амплитуды и фазы в полярной системе координат:

(:source lang=python tabwidth=4:)
>>> cmath.rect (r, phi)
(1.0000000000000002+1j)
(:sourcend:)

Функция ''phase()'' из модуля ''cmath'' возвращает значение фазы комплексного числа:

(:source lang=python tabwidth=4:)
>>> cmath.phase ( complex ('1+1j') ) * 180.0 / math.pi
45.0
(:sourcend:)

[[#other]]
!! 10. Разное

В Python 3.0 не стало функции ''xrange()'', осталась только ''range()'', но теперь она возвращает не список, а итератор. То есть по сути получается, что старую функцию ''range()'' убрали, а функцию ''xrange()'' переименовали в ''range()''. 

Если в Python 2.6 и ранее результатом выполнения скрипта 

(:source lang=python tabwidth=4:)
vals = range (1, 10, 1)
print (vals)
print ( list (vals) )
(:sourcend:)

было

(:source:)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
(:sourcend:)

А в результате выполнения кода 

(:source lang=python tabwidth=4:)
vals = xrange (1, 10, 1)
print (vals)
print ( list (vals) )
(:sourcend:)

на экран выводилось 

(:source:)
xrange(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
(:sourcend:)

То в Python 3.0 после запуска первого скрипта мы увидим

(:source:)
range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
(:sourcend:)

А второй скрипт просто не будет работать.

У словарей в Python 3.0 больше нет метода ''has_key()'', вместо него теперь надо использовать оператор ''in'', поэтому такой код будет работать во всех версиях Python, включая 3.0.

(:source lang=python tabwidth=4:)
a = dict()
a["1"] = 1
print ("1" in a)
(:sourcend:)

А следующий код в Python 3.0 работать не будет:

(:source:)
a = dict()
a["1"] = 1
print (a.has_key("1") )
(:sourcend:)

Для выявления таких устаревших методов в Python 2.6 введен новый параметр командной строки ''-3''. Если он задан, то транслятор выведет следующее предупреждение, когда будет выполнять третью строку последнего примера:

(:source:)
H:\Черновики\Python 2.6 & 3.0\other_1.py:5: DeprecationWarning: dict.has_key() not supported in 3.x; use the in operator
(:sourcend:)

Кроме метода ''has_key()'', этот параметр укажет транслятору, что надо писать похожие предупреждения, если используются функции ''apply()'', ''callable()'', ''coerce()'', ''execfile()'', ''reduce()'', ''reload()''. Кроме того, предупреждения будут выдаваться при использовании устаревших конструкций языка.

В Python 3.0 разработчики решили отказаться от оператора сравнения '' <> '', вместо него везде нужно будет использовать оператор '' != ''. Python 2.6 при использовании оператора '' <> '', если установлен параметр командной строки '' -3'', будет выдавать следующее предупреждение:

(:source:)
DeprecationWarning: <> not supported in 3.x; use !=
(:sourcend:)

В Python 3.0 (но не 2.6) появился новый способ документирования входных параметров и возвращаемого значения функций. После имени каждого параметра функции через двоеточие можно задать любое выражение, которое может быть вычислено на момент описания функции. Это выражение будет связано с именем параметра в специальном словаре. Также после описания всех параметров, но до символа '':'' можно задать выражение (с помощью оператора ''->'' ), которое будет связано с возвращаемым значением. Самым очевидным применением этой возможности является задание текстовых строк, описывающие входные параметры и возвращаемое значение. 

Рассмотрим пример:

(:source lang=python tabwidth=4:)
def foo (x: "First parameter", y: "Second parameter") -> "Summ":
	return x + y
(:sourcend:)

В этом примере с параметром ''x'' мы связали значение строкового выражения '' "First parameter" '', с параметром ''y'' - '' "Second parameter" ''. С выходным значением мы связали символьное выражение '' "Summ" ''. В Python 3.0 у всех вызываемых типов теперь есть член '' __annotations__ '', который представляем собой словарь. В качестве ключей в нем выступают строковые выражения с именами параметров, а в качестве значений - связанные с этими параметрами описания (аннотации). Если мы выполним следующий код:

(:source lang=python tabwidth=4:)
def foo (x: "First parameter", y: "Second parameter") -> "Summ":
	return x + y
	
print (foo.__annotations__)
(:sourcend:)

то в результате получим:

(:source:)
{'y': 'Second parameter', 'x': 'First parameter', 'return': 'Summ'}
(:sourcend:)

Как видно, возвращаемому значению соответствует ключ '' 'return' ''.

Здесь мы везде использовали строковые выражения, но это не обязательно. Например, можно было написать такую аннотацию:

(:source lang=python tabwidth=4:)
def foo (x: [1, 2, 3, 4], y: 5 + 7) -> None:
	pass
	
print (foo.__annotations__)
(:sourcend:)

Результатом работы этого скрипта является следующий словарь:

(:source:)
{'y': 12, 'x': [1, 2, 3, 4], 'return': None}
(:sourcend:)

Эта возможность может быть удобна для использовании в системах автоматической генерации документации, чтобы более наглядно описывать параметры функций, или при использовании в различных IDE, чтобы прямо в подсказках показывать пользователю что означает тот или иной параметр.

Документация по Python, начиная с версии 2.6, будет иметь другое оформление, более раскрашенное. Мне новое оформление понравилось, к тому же теперь при описании методов класса пишется класс, к которому принадлежит метод. Некоторые подразделы, в отличие от старой документации, теперь стали располагаться на одной странице. По содержанию в старых разделах ничего не изменилось, описания некоторых классов (например, ''CDATASection'') как были так и остались недоступны через индекс. Ссылка на онлайновую документацию вы можете найти в конце статьи в разделе [[#links | 12. Ссылки]].

В данный момент справка еще не полностью написана (попадаются моменты, где разработчики сделали себе пометки, что какие-то части нужно дописать), но в целом впечатление неплохое.

[[#finally]]
!! 11. Заключение

В заключении кратко перечислим наиболее значимые изменения, которые произошли в языках Python 2.6 и 3.0.

* Python 2.6. Появился новый параметр командной строки '' -3 '' для предупреждений об использовании конструкций, которые не будут работать в Python 3.0. 
* Python 2.6, 3.0. Появился новый способ форматирования строк с помощью метода ''format()''.
* Python 2.6, 3.0. Появился новый способ создания свойств.
* Python 2.6, 3.0. Появилась возможность создавать абстрактные классы с абстрактными методами и свойствами.
* Python 2.6, 3.0. Изменился синтаксис обработки исключений. Классы вызываемых исключений в Python 3.0 должны быть производными от базового класса ''BaseException''.
* Python 2.6, 3.0. ''with'' теперь полноценное ключевое слово.
* Python 2.6, 3.0. Введены особые числа с плавающей точкой - ''nan'', ''-inf'' и ''+inf''.
* Python 2.6, 3.0. Появились новые функции для работы с комплексными числами.
* Python 3.0. Все строки теперь используют Unicode, класса ''unicode'' больше нет.
* Python 3.0. ''print'' теперь является функцией (в Python 2.6 возможно использование ''print'' и как функции, и как ключевого слова).
* Python 3.0. Разделены операторы дробного ('' / '') и целочисленного ('' // '') деления.
* Python 3.0. Функция ''xrange()'' заменила функцию ''range()''.
* Python 3.0. Новый способ документирования функций и методов.
* Python 3.0. Оператора '' <> '' больше нет, вместо него '' != ''.

Мы рассмотрели основные нововведения языков Python 2.6 и 3.0. Из-за потери обратной совместимости язык Python 3.0 с версиями 2.х, можно назвать новым языком, который будет развиваться некоторое время параллельно версиям 2.х, хотя не думаю, что мы когда-нибудь увидим Python 2.7 с новыми возможностями. Скорее всего в ветке 2.х будут только исправляться ошибки. 

'''UPDATE:''' Похоже, что на счет Python 2.7 я ошибался, некоторые подробности вы можете прочитать у меня в блоге - [[http://jenyay.net/blog/2008/11/16/python-27/ | Python 2.7?]].

Обе версии 2.6 и 3.0 кажутся очень интересными. Если при переходе на версию 3.0 надо будет хорошенько тестировать старый код на работоспособность, то на версию 2.6 переход должен быть практически безболезненным. Осталось дождаться поддержки новых версий Python сторонними библиотеками. 

[[#links]]
!! 12. Ссылки
[[http://docs.python.org/dev | Документация по Python 2.6]]\\
[[http://docs.python.org/dev/3.0 | Документация по Python 3.0]]

[[http://docs.python.org/dev/whatsnew/2.6.html | Whats new in Python 2.6]]\\
[[http://docs.python.org/dev/3.0/whatsnew/3.0.html | What's new in Python 3.0]]

[[#comments]]
%center% (:Googlebigarticle:)

(:rater:)

(:include Site.FoxCommentBox:)

#foxbegin 1214677266a28907b0#
(:div1 class=messagehead:)

'''ilih'''&nbsp;(:if:)[-28.06.2008 - 22:21-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
> Кроме того, в python 2.6 и 3.0 появился новый метод для свойств, так называемый deleter, который вызывается, если к свойству применить функцию del().

метод для удаления свойства и сейчас есть
property( [fget[, fset[, fdel[, doc]]]]) 
http://docs.python.org/lib/built-in-funcs.html#l2h-57
(:div1end:)
#foxend 1214677266a28907b0#
#foxbegin 1214678116a30909b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-28.06.2008 - 22:35-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
'''ilih'''

Спасибо, действительно. Сейчас исправлю.
(:div1end:)
#foxend 1214678116a30909b0#
#foxbegin 1214728158a47551b0#
(:div1 class=messagehead:)

'''BION'''&nbsp;(:if:)[-29.06.2008 - 12:29-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Спасибо за статью, было интересно почитать!
(:div1end:)
#foxend 1214728158a47551b0#
#foxbegin 1214731286a93777b0#
(:div1 class=messagehead:)

'''Olexander Shtepa'''&nbsp;(:if:)[-29.06.2008 - 13:21-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Интерестно. А то лень было читать в оригинале {happy}.
(:div1end:)
#foxend 1214731286a93777b0#
#foxbegin 1214732004a96934b0#
(:div1 class=messagehead:)

'''Dmitry Vasiliev'''&nbsp;(:if:)[-29.06.2008 - 13:33-]
(:div1 class=messageitem:) 
'''Еще одно описание'''
(:div1end:)
(:div1 class=messageitem:)
Кстати, еще год назад написал похожее описание: http://hlabs.spb.ru/development/python/python3000.html
(:div1end:)
#foxend 1214732004a96934b0#
#foxbegin 1214745068a81032b0#
(:div1 class=messagehead:)

'''Valery'''&nbsp;(:if:)[-29.06.2008 - 17:11-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
{confused}{confused}{confused}{eek}{mad}
(:div1end:)
#foxend 1214745068a81032b0#
#foxbegin 1214752497a95448b0#
(:div1 class=messagehead:)

'''Andy'''&nbsp;(:if:)[-29.06.2008 - 19:14-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
"КомпЛексные" числа - поправьте опечатку.
А вообщем, авторы гады - такая подстава с делением и строками...
(:div1end:)
#foxend 1214752497a95448b0#
#foxbegin 1214754371a20613b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-29.06.2008 - 19:46-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
'''Andy'''

> "КомпЛексные" числа - поправьте опечатку

Спасибо, исправил.
(:div1end:)
#foxend 1214754371a20613b0#
#foxbegin 1214760766a34709b0#
(:div1 class=messagehead:)

'''mumu'''&nbsp;(:if:)[-29.06.2008 - 21:32-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Спасибо огромное за статью! Было очень интересно почитать
(:div1end:)
#foxend 1214760766a34709b0#
#foxbegin 1214767095a40833b0#
(:div1 class=messagehead:)

'''HardNik'''&nbsp;(:if:)[-29.06.2008 - 23:18-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Я думаю, русскоязычным пользователям и, особенно, преподавателям  небезинтересна была бы информация о идентификаторах на национальных языках. Тем более после таких бурных дискуссий на dev, и, учитывая, что это решение практически продавленно Гвидо. К сожалению, он же настоял на удалении reduce().
(:div1end:)
#foxend 1214767095a40833b0#
#foxbegin 1214767241a5307b0#
(:div1 class=messagehead:)

'''ZioN'''&nbsp;(:if:)[-29.06.2008 - 23:20-]
(:div1 class=messageitem:) 
'''м?'''
(:div1end:)
(:div1 class=messageitem:)
--------------------------------------------------------
В новых версиях Python появился новый, более удобный способ задания свойств. До Python 2.6 и 3.0 класс со свойствами мог выглядеть примерно так:

    def getx(self):
        print ("*** X.Getter(): x = {0}".format (self._x) )
        return self._x
--------------------------------------------------------

вроде говорится что до 2.6 и 3.0 и тут используете функцию format :?

(:div1end:)
#foxend 1214767241a5307b0#
#foxbegin 1214802913a74751b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-30.06.2008 - 09:15-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
'''HardNik'''

> Я думаю, русскоязычным пользователям и, особенно, преподавателям небезинтересна была бы информация о идентификаторах на национальных языках.

Пожалуй, Вы правы, хотя я не сторонник программ, где в качестве идентификаторов используются нелатинские буквы (к комментариям это не относится).

'''ZioN'''

> вроде говорится что до 2.6 и 3.0 и тут используете функцию format :? 

Мда, наверное немного нелогично, увлекся format'ом :) Попозже перепишу пример с использованием print'а.
(:div1end:)
#foxend 1214802913a74751b0#
#foxbegin 1214903772a72484b0#
(:div1 class=messagehead:)

'''mishok13'''&nbsp;(:if:)[-01.07.2008 - 13:16-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
А про dictviews, естественно, ни одного упоминания. Забыли также про dict comprehensions, новые модули multiprocessing и json, полную перестройку stdlib, унификацию типов long и int, новый синтаксис описанный в pep-3132, новые функции в itertools и т.д. Чтобы описать все новое в 3.0 одной статьи не хватит.
2HardNik:
reduce перенесли из модуля builtins в модуль functools, никто его не удалял.
(:div1end:)
#foxend 1214903772a72484b0#
#foxbegin 1214933853a15144b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-01.07.2008 - 21:37-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
'''mishok13'''
Да, это все на вторую часть статьи тянет. Кстати, multiprocessing я видел, но в документации этот модуль еще не описан.
(:div1end:)
#foxend 1214933853a15144b0#
#foxbegin 1215344966a23847b0#
(:div1 class=messagehead:)

'''Шепелев Сергей'''&nbsp;(:if:)[-06.07.2008 - 15:49-]
(:div1 class=messageitem:) 
'''TY спасибо за труд'''
(:div1end:)
(:div1 class=messageitem:)
-
(:div1end:)
#foxend 1215344966a23847b0#
#foxbegin 1222962884a24140b0#
(:div1 class=messagehead:)

'''PerereresusNeVlezaetBuggy'''&nbsp;(:if:)[-02.10.2008 - 19:54-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Спасибо, одна из немногих толковых статей по Питону (благодаря которой я понял, что не так уж много потерял, избежав тесного общения с этим языком ;) ). :)
(:div1end:)
#foxend 1222962884a24140b0#
#foxbegin 1222967910a10579b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-02.10.2008 - 21:18-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
'''PerereresusNeVlezaetBuggy'''

Мне сначала питон показался очень, мягко говоря, специфическим языком, но потом на него крепко подсел.

А вообще не ожидал тебя здесь увидеть :))
(:div1end:)
#foxend 1222967910a10579b0#
#foxbegin 1223359881a88134b0#
(:div1 class=messagehead:)

'''Dimka'''&nbsp;(:if:)[-07.10.2008 - 10:11-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
функции высоко порядка будут возвращать итераторы вместо списков.
(:div1end:)
#foxend 1223359881a88134b0#
#foxbegin 1236973612a2105b0#
(:div1 class=messagehead:)

'''Сергей'''&nbsp;(:if:)[-13.03.2009 - 22:46-]
(:div1 class=messageitem:) 
'''По поводу "глюков бета-версии"'''
(:div1end:)
(:div1 class=messageitem:)
Не исключено, что в Вашем фрагменте кода

(:source lang=python tabwidth=4:)
fp = file ("print_test.txt", "w")
print ("Тест1", "Тест2", "Тест3", file = fp)
fp.close()
(:sourcend:)

интерпретатор "не переваривает" не вторую строку, как Вы считаете, а первую. Возможно, ключевого слова "file" просто не существует. А если заменить Вашу первую строку строкой

(:source lang=python tabwidth=4:)
fp = open ("print_test.txt", "w")
(:sourcend:)

, то всё будет работать нормально.
(:div1end:)
#foxend 1236973612a2105b0#
#foxbegin 1236975224a62986b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-13.03.2009 - 23:13-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Сергей, похоже, Вы правы. Спасибо, убрал эту фразу :)
(:div1end:)
#foxend 1236975224a62986b0#
#foxbegin 1241526768a89820b0#
(:div1 class=messagehead:)

''''''&nbsp;(:if:)[-05.05.2009 - 16:32-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
где скачать!!!???{confused}{confused}{confused}
(:div1end:)
#foxend 1241526768a89820b0#

#foxbegin 1241526989a29106b0#
(:div1 class=messagehead:)

'''Jenyay'''&nbsp;(:if:)[-05.05.2009 - 16:36-]
(:div1 class=messageitem:) 
''''''
(:div1end:)
(:div1 class=messageitem:)
Здесь - http://python.org/
(:div1end:)
#foxend 1241526989a29106b0#(:Rating1: 83.64:)

